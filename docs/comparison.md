# 5种方式对比

> 帮你选择最适合的集成方式

## 快速对比表

| 方式 | 上手难度 | 灵活性 | 成本 | 适合场景 | 不适合场景 |
|------|---------|--------|------|---------|-----------|
| **Command** | ⭐ 最简单 | ⭐⭐ 低 | 低 | 新手、简单任务 | 复杂流程 |
| **Skill** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 极高 | 低 | 复杂工作流、需复用 | 一次性任务 |
| **MCP** | ⭐⭐⭐⭐ 较难 | ⭐⭐⭐ 中 | 中 | 长期协作、上下文共享 | 一次性任务 |
| **Subagent** | ⭐⭐ 简单 | ⭐⭐⭐⭐ 高 | 高 | 并行任务、预算充足 | 串行任务、预算紧张 |
| **Hooks** | ⭐⭐⭐ 中等 | ⭐⭐ 低 | 低 | 自动化、强制质检 | 需要人工判断 |

## 详细对比

### Command方式

**优点**：
- ✅ 最简单，零学习成本
- ✅ 配置只需一个.md文件
- ✅ 适合新手入门
- ✅ 快速验证想法

**缺点**：
- ❌ 灵活性低（流程固定）
- ❌ 不保存中间结果
- ❌ 不支持错误重试
- ❌ 不适合复杂任务

**适用场景**：
```bash
# ✅ 适合：快速原型
/ai-team "实现用户登录功能"

# ❌ 不适合：复杂系统
/ai-team "设计完整的微服务电商架构..." # 太复杂，用Skill
```

**推荐指数**：⭐⭐⭐⭐ （新手必备）

---

### Skill方式

**优点**：
- ✅ 功能最全（错误重试、日志、报告）
- ✅ 高度可复用（配置一次长期受益）
- ✅ 支持复杂多步骤任务
- ✅ 保存所有中间结果
- ✅ 可维护、可扩展

**缺点**：
- ❌ 配置复杂（需要写脚本）
- ❌ 需要懂bash基础
- ❌ 初次配置耗时（30分钟）

**适用场景**：
```bash
# ✅ 适合：复杂系统开发
./orchestrate.sh "RBAC权限系统，包含角色管理、权限分配、访问控制"

# ✅ 适合：需要保存中间结果
./orchestrate.sh "生成完整的API文档" # 可查看phase1/2/3

# ❌ 不适合：一次性简单任务
./orchestrate.sh "修改一个变量名" # 太简单，用Command
```

**推荐指数**：⭐⭐⭐⭐⭐ （进阶必备）

---

### MCP方式

**优点**：
- ✅ 上下文完全打通（三个AI共享记忆）
- ✅ 适合长期协作项目
- ✅ 支持会话管理（conversationId）
- ✅ 可以整天持续开发

**缺点**：
- ❌ 配置最复杂（需要写MCP Server）
- ❌ 需要懂Node.js/Python
- ❌ 调试困难
- ❌ 对简单任务过度设计

**适用场景**：
```bash
# ✅ 适合：大型重构（需要保持上下文）
重构用户模块，拆分Service层 → 生成代码 → 审查 → 改进 → 继续审查...
# conversationId让三个AI知道之前所有讨论

# ❌ 不适合：简单任务
实现Hello World # 太简单，用Command
```

**推荐指数**：⭐⭐⭐ （高级用户可选）

---

### Subagent方式

**优点**：
- ✅ 支持并行任务（时间减半）
- ✅ 配置简单（直接调用Task工具）
- ✅ 灵活性高
- ✅ 适合独立模块开发

**缺点**：
- ❌ 成本高（token消耗翻倍或更多）
- ❌ 不适合强依赖任务
- ❌ 需要主Claude协调

**适用场景**：
```bash
# ✅ 适合：前后端并行开发
Task(后端API) + Task(前端UI) → 时间减半

# ✅ 适合：独立模块并行开发
Task(用户模块) + Task(订单模块) + Task(支付模块)

# ❌ 不适合：串行强依赖任务
先分析需求 → 再生成代码 → 再审查 # 必须串行，用Skill
```

**推荐指数**：⭐⭐⭐ （预算充足时使用）

---

### Hooks方式

**优点**：
- ✅ 全自动（特定时机触发）
- ✅ 强制质检（防止低质量代码）
- ✅ 配置简单
- ✅ 适合规范化流程

**缺点**：
- ❌ 灵活性低
- ❌ 容易误触发
- ❌ 调试困难
- ❌ 不适合需要人工判断的场景

**适用场景**：
```bash
# ✅ 适合：Git提交前自动审查
git commit → [Hook触发] → Gemini审查 → 报告问题

# ✅ 适合：强制代码规范检查
写文件 → [Hook触发] → 检查代码风格

# ❌ 不适合：调试期间
频繁修改代码 → Hook频繁触发 → 太慢！
```

**推荐指数**：⭐⭐⭐⭐ （团队规范化必备）

---

## 选择决策树

```
                开始
                 ↓
         你是新手吗？
          ↙     ↘
        是       否
         ↓        ↓
      Command   任务复杂吗？
                 ↙     ↘
              简单     复杂
                ↓       ↓
             Command  需要并行吗？
                       ↙     ↘
                     是      否
                      ↓       ↓
                  Subagent  需要上下文共享吗？
                             ↙     ↘
                           是      否
                            ↓       ↓
                          MCP     Skill
```

## 实际使用建议

### 新手（1-2周）
- **第1周**：只用Command，熟悉流程
- **第2周**：尝试Skill，处理复杂任务

### 进阶用户（1-3个月）
- **日常开发**：Command（快速任务）+ Skill（复杂任务）
- **质检流程**：配置Hooks（Git提交前审查）
- **大型项目**：考虑MCP（保持上下文）

### 高级用户（3个月+）
- **灵活组合**：根据任务特点选择最佳方式
- **自定义扩展**：修改Skill脚本、编写MCP Server
- **团队规范**：制定Hooks规则、统一工作流

## 成本对比

**假设任务**：实现JWT登录功能（10K输入 + 5K输出）

| 方式 | Token消耗 | 成本 | 时间 |
|------|----------|------|------|
| 全用Sonnet | 15K tokens | $0.105 | 7分钟 |
| Command（Sonnet+Codex+Gemini） | 混合 | $0.056 | 7分钟 |
| Skill（同上） | 混合 | $0.056 | 7分钟 |
| MCP（同上+上下文） | 混合+10% | $0.062 | 8分钟 |
| Subagent（2个并行） | 混合×2 | $0.112 | 4分钟 |
| Hooks（自动触发） | 混合 | $0.056 | 自动 |

**结论**：Command/Skill/Hooks成本最低（省47%），Subagent速度最快但成本高。

---

**下一步**：
- [使用说明](usage.md) - 学习每种方式的详细用法
- [实战案例](../examples/) - 查看真实项目案例
- [踩坑记录](troubleshooting.md) - 常见问题解决
